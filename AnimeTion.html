// تعريف المتغيرات والعناصر
const canvas = document.getElementById('animationCanvas');
const ctx = canvas.getContext('2d');
const timeline = document.querySelector('.timeline');

// تعيين أبعاد الكانفاس
canvas.width = 800;
canvas.height = 600;

// متغيرات حالة الرسم
let currentTool = 'line';
let drawing = false;
let startX, startY;
let currentZoom = 1;

// مصفوفة لتخزين بيانات الأنيميشن (إطارات، طبقات، أشكال)
let animationData = [{
    layers: [[]]
}];
let currentFrame = 0;
let currentLayer = 0;
let history = []; // للتراجع والإعادة
let historyIndex = -1;

// ===================================
// الوظائف الرئيسية
// ===================================

// وظيفة إعادة رسم الكانفاس
function redrawCanvas() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const frameData = animationData[currentFrame];
    
    // رسم كل الطبقات
    frameData.layers.forEach(layer => {
        layer.forEach(shape => {
            if (shape) {
                ctx.beginPath();
                ctx.strokeStyle = shape.color;
                ctx.lineWidth = shape.width;
                
                // رسم الأشكال بناءً على نوعها
                if (shape.type === 'line') {
                    ctx.moveTo(shape.startX, shape.startY);
                    ctx.lineTo(shape.endX, shape.endY);
                    ctx.stroke();
                } else if (shape.type === 'rectangle') {
                    ctx.strokeRect(shape.x, shape.y, shape.width, shape.height);
                } else if (shape.type === 'circle') {
                    ctx.arc(shape.x, shape.y, shape.radius, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
        });
    });
}

// وظيفة حفظ حالة المشروع للتراجع
function saveState() {
    // حذف الحالات القديمة بعد التراجع
    if (historyIndex < history.length - 1) {
        history = history.slice(0, historyIndex + 1);
    }
    const state = JSON.parse(JSON.stringify(animationData));
    history.push(state);
    historyIndex++;
}

// ===================================
// التحكم في الأحداث (Events)
// ===================================

// بداية الرسم
canvas.addEventListener('mousedown', (e) => {
    if (currentTool === 'zoom') return; // منع الرسم عند التكبير
    
    drawing = true;
    startX = e.offsetX / currentZoom;
    startY = e.offsetY / currentZoom;
});

// نهاية الرسم
canvas.addEventListener('mouseup', (e) => {
    if (!drawing) return;
    drawing = false;

    const endX = e.offsetX / currentZoom;
    const endY = e.offsetY / currentZoom;
    const currentLayerData = animationData[currentFrame].layers[currentLayer];
    
    // بناء الشكل الجديد
    let newShape;
    const color = document.getElementById('color-picker').value;
    const width = document.getElementById('line-width').value;
    
    if (currentTool === 'line') {
        newShape = { type: 'line', startX, startY, endX, endY, color, width };
    } else if (currentTool === 'rect') {
        const rectWidth = endX - startX;
        const rectHeight = endY - startY;
        newShape = { type: 'rectangle', x: startX, y: startY, width: rectWidth, height: rectHeight, color, width };
    } else if (currentTool === 'circle') {
        const radius = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
        newShape = { type: 'circle', x: startX, y: startY, radius, color, width };
    }
    
    if (newShape) {
        currentLayerData.push(newShape);
        saveState();
        redrawCanvas();
    }
});

// ===================================
// وظائف الأدوات
// ===================================

// اختيار الأدوات
document.getElementById('line-tool').addEventListener('click', () => currentTool = 'line');
document.getElementById('rect-tool').addEventListener('click', () => currentTool = 'rect');
document.getElementById('circle-tool').addEventListener('click', () => currentTool = 'circle');
document.getElementById('select-tool').addEventListener('click', () => currentTool = 'select');
document.getElementById('zoom-tool').addEventListener('click', () => currentTool = 'zoom');

// وظيفة التراجع
document.getElementById('undo-btn').addEventListener('click', () => {
    if (historyIndex > 0) {
        historyIndex--;
        animationData = JSON.parse(JSON.stringify(history[historyIndex]));
        redrawCanvas();
    }
});

// وظيفة الإعادة
document.getElementById('redo-btn').addEventListener('click', () => {
    if (historyIndex < history.length - 1) {
        historyIndex++;
        animationData = JSON.parse(JSON.stringify(history[historyIndex]));
        redrawCanvas();
    }
});

// إضافة إطار جديد
document.getElementById('add-frame').addEventListener('click', () => {
    const newFrame = {
        // تكرار الرسم من الإطار اللي قبله
        layers: JSON.parse(JSON.stringify(animationData[currentFrame].layers))
    };
    animationData.push(newFrame);
    currentFrame = animationData.length - 1;
    updateFrameInfo();
    redrawCanvas();
    saveState();
});

// إضافة طبقة جديدة
document.getElementById('add-layer').addEventListener('click', () => {
    animationData[currentFrame].layers.push([]);
    currentLayer = animationData[currentFrame].layers.length - 1;
    updateLayersList();
    saveState();
});

// ===================================
// وظائف التصدير والاستيراد
// ===================================

// تصدير JSON
document.getElementById('export-json').addEventListener('click', () => {
    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(animationData));
    const downloadAnchorNode = document.createElement('a');
    downloadAnchorNode.setAttribute("href", dataStr);
    downloadAnchorNode.setAttribute("download", "animation.json");
    document.body.appendChild(downloadAnchorNode);
    downloadAnchorNode.click();
    downloadAnchorNode.remove();
});

// استيراد JSON
document.getElementById('import-json').addEventListener('change', (e) => {
    const file = e.target.files[0];
    const reader = new FileReader();
    reader.onload = (event) => {
        animationData = JSON.parse(event.target.result);
        currentFrame = 0;
        currentLayer = 0;
        updateFrameInfo();
        updateLayersList();
        redrawCanvas();
    };
    reader.readAsText(file);
});

// وظيفة التصدير MP4
// **ملاحظة:** دي وظيفة معقدة جداً ومحتاجة مكتبة خارجية زي FFmpeg.js. الكود ده مجرد زرار مش هيشتغل من غير المكتبة.
document.getElementById('export-mp4').addEventListener('click', () => {
    alert('تصدير MP4 يتطلب مكتبة خارجية (مثل FFmpeg.js) وهو أمر معقد.');
});

// ===================================
// تحديث الواجهة
// ===================================

function updateFrameInfo() {
    document.getElementById('frame-info').textContent = `إطار ${currentFrame + 1} / ${animationData.length}`;
}

function updateLayersList() {
    const layersList = document.getElementById('layers-list');
    layersList.innerHTML = '';
    animationData[currentFrame].layers.forEach((layer, index) => {
        const layerDiv = document.createElement('div');
        layerDiv.textContent = `طبقة ${index + 1}`;
        layerDiv.dataset.index = index;
        if (index === currentLayer) {
            layerDiv.classList.add('active-layer');
        }
        layerDiv.addEventListener('click', () => {
            currentLayer = index;
            updateLayersList();
        });
        layersList.appendChild(layerDiv);
    });
}

// البدء
redrawCanvas();
updateFrameInfo();
updateLayersList();
saveState();

// **ملحوظة:**
// - الكود ده بيوفر الأساسيات، لكنه محتاج تطوير أكتر عشان يكون متكامل.
// - التكبير والتصغير محتاج شغل في الـ `event listener` عشان يشتغل مظبوط.
// - أداة التحديد محتاجة برمجة عشان تتعرف على الأشكال الموجودة على الكانفاس.
// - التصدير لـ MP4 محتاج مكتبة خارجية.
