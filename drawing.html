<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>تطبيق الرسم مع أدوات متقدمة</title>
<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden; touch-action: none; font-family: sans-serif;
  }
  #menu {
    position: fixed;
    top: 0; right: 0; left: 0;
    background: #f0f0f0;
    padding: 10px;
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    align-items: center;
    z-index: 20;
  }
  canvas {
    position: absolute;
    top: 50px; left: 0;
    width: 100%;
    height: calc(100% - 50px);
    background: white;
    touch-action: none;
  }
  .zoom-info {
    position: fixed;
    bottom: 10px;
    left: 10px;
    background: rgba(0,0,0,0.5);
    color: white;
    padding: 5px 10px;
    border-radius: 5px;
    font-size: 12px;
    z-index: 30;
  }
  #toolDropdown {
    position: relative;
  }
  #toolDropdownContent {
    display: none;
    position: absolute;
    top: 100%;
    right: 0;
    background: white;
    border: 1px solid #ccc;
    border-radius: 5px;
    min-width: 160px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    z-index: 50;
  }
  #toolDropdownContent button {
    width: 100%;
    border: none;
    background: none;
    padding: 8px 12px;
    text-align: right;
    cursor: pointer;
    font-size: 14px;
    display: flex;
    justify-content: flex-end;
    gap: 8px;
  }
  #toolDropdownContent button:hover {
    background-color: #eee;
  }
  #menu button, #menu label {
    font-size: 20px;
    cursor: pointer;
    background: none;
    border: none;
    padding: 5px 8px;
    user-select: none;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  #menu label {
    cursor: default;
  }
  #menu input[type="color"], #menu input[type="number"] {
    width: 40px;
    height: 30px;
    margin-left: 5px;
    cursor: pointer;
    border-radius: 4px;
    border: 1px solid #ccc;
  }
</style>
</head>
<body>

<div id="menu">
  <label title="اختر اللون">🎨<input type="color" id="colorPicker" value="#000000"></label>
  <label title="حجم الفرشاة">🖌️<input type="number" id="brushSize" min="1" max="100" value="3" step="1"></label>
  <button id="undoBtn" title="تراجع">↩️</button>
  <button id="redoBtn" title="إعادة">↪️</button>
  <button id="clearBtn" title="مسح">🧹</button>
  <button id="saveBtn" title="حفظ صورة">💾</button>
  <button id="saveJsonBtn" title="حفظ JSON">📁</button>
  <button id="loadJsonBtn" title="فتح JSON">📂</button>
  
  <div id="toolDropdown">
    <button id="toggleToolList" title="أدوات الرسم">⚙️</button>
    <div id="toolDropdownContent" role="menu" aria-hidden="true">
      <button data-tool="brush" title="فرشاة">🖌️ فرشاة</button>
      <button data-tool="highlighter" title="ماركر">🎯 ماركر</button>
      <button data-tool="pencil" title="قلم رصاص">✏️ قلم رصاص</button>
      <button data-tool="fountainPen" title="قلم حبر">🖋️ قلم حبر</button>
      <button data-tool="airbrush" title="بخاخ">🌫️ بخاخ</button>
      <button data-tool="eraser" title="ممحاة">🩹 ممحاة</button>
      <button data-tool="softEraser" title="ممحاة ناعمة">🧽 ممحاة ناعمة</button>
      <button data-tool="blender" title="ممزج">🔄 مزج الألوان</button>
      <button data-tool="fill" title="تعبئة">🪣 تعبئة</button>
      <button data-tool="glowpen" title="قلم توهج">✨🖊️ قلم توهج</button>
      <button data-tool="pixelpen" title="قلم بكسل">🟦 قلم بكسل</button>
      <button data-tool="line" title="خط مستقيم">📏 خط مستقيم</button>
    </div>
  </div>
</div>

<canvas id="canvas"></canvas>
<div class="zoom-info" id="zoomInfo">زوم: 1x</div>

<script>
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  const colorPicker = document.getElementById("colorPicker");
  const brushSize = document.getElementById("brushSize");
  const undoBtn = document.getElementById("undoBtn");
  const redoBtn = document.getElementById("redoBtn");
  const clearBtn = document.getElementById("clearBtn");
  const saveBtn = document.getElementById("saveBtn");
  const saveJsonBtn = document.getElementById("saveJsonBtn");
  const loadJsonBtn = document.getElementById("loadJsonBtn");
  const zoomInfo = document.getElementById("zoomInfo");
  const toggleToolList = document.getElementById("toggleToolList");
  const toolDropdownContent = document.getElementById("toolDropdownContent");

  const jsonFileInput = document.createElement("input");
  jsonFileInput.type = "file";
  jsonFileInput.accept = ".json";
  jsonFileInput.style.display = "none";
  document.body.appendChild(jsonFileInput);

  let width = window.innerWidth;
  let height = window.innerHeight - 50;
  canvas.width = width;
  canvas.height = height;

  let paths = [];
  let undonePaths = [];
  let currentPath = null;
  let drawing = false;
  let hasMoved = false;
  let lastX = 0;
  let lastY = 0;

  let zoom = 1;
  let panX = 0;
  let panY = 0;
  let isZooming = false;
  let lastTouchDist = 0;
  let zoomEndTime = 0;
  const ZOOM_COOLDOWN = 200;
  const MIN_ZOOM = 1e-25;
  const MAX_ZOOM = 1e25;

  let currentTool = "brush";

  // فتح/غلق قائمة الأدوات
  toggleToolList.addEventListener("click", () => {
    if (toolDropdownContent.style.display === "block") {
      toolDropdownContent.style.display = "none";
      toolDropdownContent.setAttribute("aria-hidden", "true");
    } else {
      toolDropdownContent.style.display = "block";
      toolDropdownContent.setAttribute("aria-hidden", "false");
    }
  });

  // إغلاق القائمة عند الضغط خارجها
  window.addEventListener("click", (e) => {
    if (!toggleToolList.contains(e.target) && !toolDropdownContent.contains(e.target)) {
      toolDropdownContent.style.display = "none";
      toolDropdownContent.setAttribute("aria-hidden", "true");
    }
  });

  // تغيير الأداة عند اختيارها
  toolDropdownContent.querySelectorAll("button").forEach(btn => {
    btn.addEventListener("click", () => {
      currentTool = btn.getAttribute("data-tool");
      toolDropdownContent.style.display = "none";
      toolDropdownContent.setAttribute("aria-hidden", "true");
      console.log("تم اختيار الأداة:", currentTool);
    });
  });

  // تحديث عرض الزوم
  function updateZoomInfo() {
    if (zoom < 0.0001 || zoom > 10000) {
      zoomInfo.textContent = `زوم: ${zoom.toExponential(2)}x`;
    } else {
      zoomInfo.textContent = `زوم: ${zoom.toFixed(zoom >= 1 ? 2 : 8)}x`;
    }
  }

  // مساعدات للأدوات

  // رسم بكسل (مربع صغير)
  function drawPixel(x, y, size, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x - size/2, y - size/2, size, size);
  }

  // تأثير البخاخ
  function airbrushEffect(x, y, size, color) {
    const density = 15;
    ctx.fillStyle = color;
    ctx.globalAlpha = 0.04;
    for(let i=0; i<density; i++) {
      const offsetX = (Math.random() - 0.5) * size * 2;
      const offsetY = (Math.random() - 0.5) * size * 2;
      ctx.beginPath();
      ctx.arc(x + offsetX, y + offsetY, size/5, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  // تأثير مزج (blender)
  function blendEffect(x, y, size) {
    const gradient = ctx.createRadialGradient(x, y, size*0.3, x, y, size);
    gradient.addColorStop(0, 'rgba(255,255,255,0.7)');
    gradient.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(x, y, size, 0, Math.PI * 2);
    ctx.fill();
  }

  // تعبئة flood fill (نقطة بداية ولون)
  function floodFill(startX, startY, fillColor) {
    const imgData = ctx.getImageData(0,0,canvas.width,canvas.height);
    const data = imgData.data;
    const width = imgData.width;
    const height = imgData.height;

    function matchColor(x,y,color) {
      const index = (y * width + x) * 4;
      return (
        data[index] === color[0] &&
        data[index+1] === color[1] &&
        data[index+2] === color[2] &&
        data[index+3] === color[3]
      );
    }

    function setColor(x,y,color) {
      const index = (y * width + x) * 4;
      data[index] = color[0];
      data[index+1] = color[1];
      data[index+2] = color[2];
      data[index+3] = color[3];
    }

    const startPos = (Math.floor(startY) * width + Math.floor(startX)) * 4;
    const startColor = [data[startPos], data[startPos+1], data[startPos+2], data[startPos+3]];

    const fillColRGBA = hexToRgba(fillColor);

    if (arraysEqual(startColor, fillColRGBA)) return; 

    let stack = [[Math.floor(startX), Math.floor(startY)]];

    while(stack.length > 0) {
      const [x,y] = stack.pop();
      if(x < 0 || x >= width || y < 0 || y >= height) continue;
      if(matchColor(x,y,startColor)) {
        setColor(x,y,fillColRGBA);
        stack.push([x+1,y],[x-1,y],[x,y+1],[x,y-1]);
      }
    }
    ctx.putImageData(imgData, 0, 0);
  }

  function hexToRgba(hex) {
    hex = hex.replace('#','');
    if(hex.length === 3) {
      hex = hex.split('').map(c => c+c).join('');
    }
    const bigint = parseInt(hex,16);
    return [
      (bigint >> 16) & 255,
      (bigint >> 8) & 255,
      bigint & 255,
      255
    ];
  }
  function arraysEqual(a,b) {
    if(a.length !== b.length) return false;
    for(let i=0; i<a.length; i++) {
      if(a[i] !== b[i]) return false;
    }
    return true;
  }

  // رسم المسار بحسب الأداة
  function drawPathSegment(lastX, lastY, pos) {
    switch(currentTool) {
      case "highlighter":
        ctx.strokeStyle = currentPath.color;
        ctx.globalAlpha = 0.3;
        ctx.lineWidth = currentPath.size * 3;
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
        ctx.globalAlpha = 1;
        break;

      case "pencil":
        ctx.strokeStyle = currentPath.color;
        ctx.globalAlpha = 0.6;
        ctx.lineWidth = Math.max(1, currentPath.size / 3);
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
        ctx.globalAlpha = 1;
        break;

      case "fountainPen":
        ctx.strokeStyle = currentPath.color;
        ctx.lineWidth = currentPath.size * 1.5;
        ctx.lineCap = "round";
        ctx.shadowColor = currentPath.color;
        ctx.shadowBlur = 1;
        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
        ctx.shadowBlur = 0;
        break;

      case "airbrush":
        airbrushEffect(pos.x, pos.y, currentPath.size, currentPath.color);
        break;

      case "eraser":
        ctx.clearRect(pos.x - currentPath.size/2, pos.y - currentPath.size/2, currentPath.size, currentPath.size);
        break;

      case "softEraser":
        ctx.fillStyle = "rgba(255,255,255,0.3)";
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, currentPath.size/2, 0, Math.PI * 2);
        ctx.fill();
        break;

      case "blender":
        blendEffect(pos.x, pos.y, currentPath.size);
        break;

      case "glowpen":
        ctx.strokeStyle = currentPath.color;
        ctx.lineWidth = currentPath.size;
        ctx.shadowColor = currentPath.color;
        ctx.shadowBlur = 15;
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
        ctx.shadowBlur = 0;
        break;

      case "pixelpen":
        drawPixel(pos.x, pos.y, currentPath.size, currentPath.color);
        break;

      case "line":
        // لا يرسم أثناء السحب، الرسم يتم عند الانتهاء فقط
        break;

      case "fill":
        // تعبئة بلون عند نقطة الضغط
        floodFill(pos.x, pos.y, currentPath.color);
        break;

      default: // brush
        ctx.strokeStyle = currentPath.color;
        ctx.lineWidth = currentPath.size;
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
    }
  }

  // إعادة رسم كل المسارات
  function drawAll() {
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.setTransform(zoom, 0, 0, zoom, panX, panY);

    for (let path of paths) {
      ctx.strokeStyle = path.color;
      ctx.lineWidth = path.size;
      ctx.lineCap = "round";
      ctx.lineJoin = "round";

      if(path.tool === "line") {
        if(path.points.length >= 2) {
          ctx.beginPath();
          ctx.moveTo(path.points[0].x, path.points[0].y);
          ctx.lineTo(path.points[path.points.length-1].x, path.points[path.points.length-1].y);
          ctx.stroke();
        }
      } else if(path.tool === "pixelpen") {
        for(let pt of path.points) {
          drawPixel(pt.x, pt.y, path.size, path.color);
        }
      } else if(path.tool === "highlighter") {
        ctx.globalAlpha = 0.3;
        ctx.beginPath();
        for(let i=0; i<path.points.length-1; i++) {
          ctx.moveTo(path.points[i].x, path.points[i].y);
          ctx.lineTo(path.points[i+1].x, path.points[i+1].y);
        }
        ctx.stroke();
        ctx.globalAlpha = 1;
      } else if(path.tool === "softEraser") {
        ctx.fillStyle = "rgba(255,255,255,0.3)";
        for(let pt of path.points) {
          ctx.beginPath();
          ctx.arc(pt.x, pt.y, path.size/2, 0, Math.PI*2);
          ctx.fill();
        }
      } else if(path.tool === "blender") {
        for(let pt of path.points) {
          blendEffect(pt.x, pt.y, path.size);
        }
      } else if(path.tool === "airbrush") {
        for(let pt of path.points) {
          airbrushEffect(pt.x, pt.y, path.size, path.color);
        }
      } else if(path.tool === "eraser") {
        for(let pt of path.points) {
          ctx.clearRect(pt.x - path.size/2, pt.y - path.size/2, path.size, path.size);
        }
      } else if(path.tool === "fountainPen") {
        ctx.shadowColor = path.color;
        ctx.shadowBlur = 1;
        ctx.beginPath();
        ctx.moveTo(path.points[0].x, path.points[0].y);
        for(let i=1; i<path.points.length; i++) {
          ctx.lineTo(path.points[i].x, path.points[i].y);
        }
        ctx.lineWidth = path.size * 1.5;
        ctx.stroke();
        ctx.shadowBlur = 0;
      } else if(path.tool === "glowpen") {
        ctx.shadowColor = path.color;
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.moveTo(path.points[0].x, path.points[0].y);
        for(let i=1; i<path.points.length; i++) {
          ctx.lineTo(path.points[i].x, path.points[i].y);
        }
        ctx.lineWidth = path.size;
        ctx.stroke();
        ctx.shadowBlur = 0;
      } else { // brush and pencil default
        ctx.globalAlpha = path.tool === "pencil" ? 0.6 : 1;
        ctx.beginPath();
        ctx.moveTo(path.points[0].x, path.points[0].y);
        for(let i=1; i<path.points.length; i++) {
          ctx.lineTo(path.points[i].x, path.points[i].y);
        }
        ctx.lineWidth = path.size;
        ctx.strokeStyle = path.color;
        ctx.lineCap = "round";
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
    }
  }

  // تحويل إحداثيات الشاشة إلى إحداثيات اللوحة مع الزوم والبان
  function screenToCanvas(x, y) {
    return {
      x: (x - panX) / zoom,
      y: (y - panY) / zoom
    };
  }

  // بدء الرسم
  function startDrawing(x, y) {
    drawing = true;
    hasMoved = false;
    const pos = screenToCanvas(x, y);
    currentPath = {
      tool: currentTool,
      color: currentTool === "eraser" || currentTool === "softEraser" ? "#FFFFFF" : colorPicker.value,
      size: parseInt(brushSize.value),
      points: [pos]
    };

    if(currentTool === "fill") {
      floodFill(pos.x, pos.y, currentPath.color);
      drawing = false;
      currentPath = null;
      return;
    }

    if(currentTool === "line") {
      // فقط تخزين البداية
      currentPath.start = pos;
      currentPath.points = [pos, pos];
    }

    undonePaths = []; // مسح قائمة الإعادة عند رسم جديد
  }

  // تحديث الرسم أثناء السحب
  function moveDrawing(x, y) {
    if (!drawing) return;
    hasMoved = true;
    const pos = screenToCanvas(x, y);
    if(currentTool === "line") {
      currentPath.points[1] = pos; // تحديث نهاية الخط
      drawAll();
      // رسم الخط الحالي على الكانفاس فوق
      ctx.setTransform(zoom, 0, 0, zoom, panX, panY);
      ctx.strokeStyle = currentPath.color;
      ctx.lineWidth = currentPath.size;
      ctx.beginPath();
      ctx.moveTo(currentPath.start.x, currentPath.start.y);
      ctx.lineTo(pos.x, pos.y);
      ctx.stroke();
    } else {
      const last = currentPath.points[currentPath.points.length -1];
      currentPath.points.push(pos);
      ctx.setTransform(zoom, 0, 0, zoom, panX, panY);
      drawPathSegment(last.x, last.y, pos);
    }
  }

  // إنهاء الرسم
  function endDrawing(x, y) {
    if (!drawing) return;
    drawing = false;
    if(!hasMoved && currentTool !== "fill" && currentTool !== "line") {
      // رسم نقطة واحدة لو لم يتحرك الإصبع
      const pos = screenToCanvas(x, y);
      currentPath.points.push(pos);
      ctx.setTransform(zoom, 0, 0, zoom, panX, panY);
      drawPathSegment(pos.x, pos.y, pos);
    }

    if(currentTool === "line" && currentPath.points.length === 2) {
      // فقط نضيف خط كامل
      paths.push(currentPath);
      currentPath = null;
      drawAll();
      return;
    }

    if(currentPath && currentPath.points.length > 0) {
      paths.push(currentPath);
      currentPath = null;
      drawAll();
    }
  }

  // تراجع
  undoBtn.addEventListener("click", () => {
    if(paths.length > 0) {
      undonePaths.push(paths.pop());
      drawAll();
    }
  });

  // إعادة
  redoBtn.addEventListener("click", () => {
    if(undonePaths.length > 0) {
      paths.push(undonePaths.pop());
      drawAll();
    }
  });

  // مسح الكل
  clearBtn.addEventListener("click", () => {
    paths = [];
    undonePaths = [];
    drawAll();
  });

  // حفظ الصورة PNG
  saveBtn.addEventListener("click", () => {
    const link = document.createElement("a");
    link.download = "drawing.png";
    link.href = canvas.toDataURL();
    link.click();
  });

  // حفظ JSON
  saveJsonBtn.addEventListener("click", () => {
    const dataStr = JSON.stringify(paths);
    const blob = new Blob([dataStr], {type:"application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "drawing.json";
    a.click();
    URL.revokeObjectURL(url);
  });

  // فتح JSON
  loadJsonBtn.addEventListener("click", () => {
    jsonFileInput.click();
  });

  jsonFileInput.addEventListener("change", (e) => {
    const file = e.target.files[0];
    if(!file) return;
    const reader = new FileReader();
    reader.onload = (event) => {
      try {
        const loadedPaths = JSON.parse(event.target.result);
        if(Array.isArray(loadedPaths)) {
          paths = loadedPaths;
          undonePaths = [];
          drawAll();
        }
      } catch(err) {
        alert("خطأ في تحميل الملف");
      }
    };
    reader.readAsText(file);
  });

  // أحداث الماوس / اللمس
  let pointerId = null;

  function pointerDown(e) {
    if(pointerId !== null) return; // يدعم إصبع واحد فقط للرسم
    pointerId = e.pointerId;
    startDrawing(e.clientX, e.clientY);
  }
  function pointerMove(e) {
    if(e.pointerId !== pointerId) return;
    moveDrawing(e.clientX, e.clientY);
  }
  function pointerUp(e) {
    if(e.pointerId !== pointerId) return;
    pointerId = null;
    endDrawing(e.clientX, e.clientY);
  }

  canvas.addEventListener("pointerdown", pointerDown);
  canvas.addEventListener("pointermove", pointerMove);
  canvas.addEventListener("pointerup", pointerUp);
  canvas.addEventListener("pointercancel", pointerUp);
  canvas.addEventListener("pointerout", pointerUp);
  canvas.addEventListener("pointerleave", pointerUp);

  // التعامل مع الزوم (لمس بصباعين) والبان
  canvas.addEventListener("touchmove", (e) => {
    if(e.touches.length === 2) {
      e.preventDefault();

      const t1 = e.touches[0];
      const t2 = e.touches[1];
      const dist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);

      if(!isZooming) {
        isZooming = true;
        lastTouchDist = dist;
        return;
      }

      let delta = dist - lastTouchDist;
      const zoomFactor = 0.005;

      zoom += delta * zoomFactor;
      if (zoom < MIN_ZOOM) zoom = MIN_ZOOM;
      if (zoom > MAX_ZOOM) zoom = MAX_ZOOM;
      lastTouchDist = dist;

      // تحديث مركز الزوم ليكون مركز اللمس
      const centerX = (t1.clientX + t2.clientX) / 2;
      const centerY = (t1.clientY + t2.clientY) / 2;

      panX += centerX * (1 - (zoom / (zoom - delta * zoomFactor)));
      panY += centerY * (1 - (zoom / (zoom - delta * zoomFactor)));

      drawAll();
      updateZoomInfo();
    }
  }, {passive: false});

  canvas.addEventListener("touchend", (e) => {
    if(e.touches.length < 2) {
      isZooming = false;
    }
  });

  // تحديث حجم اللوحة عند تغيير حجم النافذة
  window.addEventListener("resize", () => {
    width = window.innerWidth;
    height = window.innerHeight - 50;
    canvas.width = width;
    canvas.height = height;
    drawAll();
  });

  updateZoomInfo();
  drawAll();
</script>

</body>
</html>
