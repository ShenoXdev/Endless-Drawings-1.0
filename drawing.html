<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>تطبيق الرسم مع أدوات وتأثيرات متقدمة</title>
<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden; touch-action: none; font-family: sans-serif;
  }
  #menu {
    position: fixed;
    top: 0; right: 0; left: 0;
    background: #f0f0f0;
    padding: 10px;
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    align-items: center;
    z-index: 20;
  }
  canvas {
    position: absolute;
    top: 50px; left: 0;
    width: 100%;
    height: calc(100% - 50px);
    background: white;
    touch-action: none;
  }
  .zoom-info {
    position: fixed;
    bottom: 10px;
    left: 10px;
    background: rgba(0,0,0,0.5);
    color: white;
    padding: 5px 10px;
    border-radius: 5px;
    font-size: 12px;
    z-index: 30;
  }
  #toolDropdown {
    position: relative;
  }
  #toolDropdownContent {
    display: none;
    position: absolute;
    top: 100%;
    right: 0;
    background: white;
    border: 1px solid #ccc;
    border-radius: 5px;
    min-width: 160px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    z-index: 50;
  }
  #toolDropdownContent button {
    width: 100%;
    border: none;
    background: none;
    padding: 8px 12px;
    text-align: right;
    cursor: pointer;
    font-size: 14px;
    display: flex;
    justify-content: flex-end;
    gap: 8px;
  }
  #toolDropdownContent button:hover {
    background-color: #eee;
  }
  #menu button, #menu label {
    font-size: 20px;
    cursor: pointer;
    background: none;
    border: none;
    padding: 5px 8px;
    user-select: none;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  #menu label {
    cursor: default;
  }
  #menu input[type="color"], #menu input[type="number"] {
    width: 40px;
    height: 30px;
    margin-left: 5px;
    cursor: pointer;
    border-radius: 4px;
    border: 1px solid #ccc;
  }
</style>
</head>
<body>

<div id="menu">
  <label title="اختر اللون">🎨<input type="color" id="colorPicker" value="#000000"></label>
  <label title="حجم الفرشاة">🖌️<input type="number" id="brushSize" min="1" max="100" value="3" step="1"></label>
  <button id="undoBtn" title="تراجع">↩️</button>
  <button id="redoBtn" title="إعادة">↪️</button>
  <button id="clearBtn" title="مسح">🧹</button>
  <button id="saveBtn" title="حفظ صورة">💾</button>
  <button id="saveJsonBtn" title="حفظ JSON">📁</button>
  <button id="loadJsonBtn" title="فتح JSON">📂</button>
  
  <div id="toolDropdown">
    <button id="toggleToolList" title="أدوات الرسم">⚙️</button>
    <div id="toolDropdownContent" role="menu" aria-hidden="true">
      <button data-tool="brush" title="فرشاة">🖌️ فرشاة</button>
      <button data-tool="highlighter" title="ماركر">🎯 ماركر</button>
      <button data-tool="pencil" title="قلم رصاص">✏️ قلم رصاص</button>
      <button data-tool="fountainPen" title="قلم حبر">🖋️ قلم حبر</button>
      <button data-tool="airbrush" title="بخاخ">🌫️ بخاخ</button>
      <button data-tool="eraser" title="ممحاة">🩹 ممحاة</button>
      <button data-tool="softEraser" title="ممحاة ناعمة">🧽 ممحاة ناعمة</button>
      <button data-tool="blender" title="ممزج">🔄 مزج الألوان</button>
      <button data-tool="fill" title="تعبئة">🪣 تعبئة</button>
      <button data-tool="glowpen" title="قلم توهج">✨🖊️ قلم توهج</button>
      <button data-tool="pixelpen" title="قلم بكسل">🟦 قلم بكسل</button>
      <button data-tool="line" title="خط مستقيم">📏 خط مستقيم</button>
    </div>
  </div>
</div>

<canvas id="canvas"></canvas>
<div class="zoom-info" id="zoomInfo">زوم: 1x</div>

<script>
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  const colorPicker = document.getElementById("colorPicker");
  const brushSize = document.getElementById("brushSize");
  const undoBtn = document.getElementById("undoBtn");
  const redoBtn = document.getElementById("redoBtn");
  const clearBtn = document.getElementById("clearBtn");
  const saveBtn = document.getElementById("saveBtn");
  const saveJsonBtn = document.getElementById("saveJsonBtn");
  const loadJsonBtn = document.getElementById("loadJsonBtn");
  const jsonFileInput = document.createElement("input");
  jsonFileInput.type = "file";
  jsonFileInput.accept = ".json";
  jsonFileInput.style.display = "none";
  document.body.appendChild(jsonFileInput);
  const zoomInfo = document.getElementById("zoomInfo");
  
  const toggleToolList = document.getElementById("toggleToolList");
  const toolDropdownContent = document.getElementById("toolDropdownContent");

  let width = window.innerWidth;
  let height = window.innerHeight - 50;
  canvas.width = width;
  canvas.height = height;

  let paths = [];
  let undonePaths = [];
  let currentPath = null;
  let drawing = false;
  let hasMoved = false;
  let lastX = 0;
  let lastY = 0;

  let zoom = 1;
  let panX = 0;
  let panY = 0;
  let isZooming = false;
  let lastTouchDist = 0;
  let zoomEndTime = 0;
  const ZOOM_COOLDOWN = 200;
  const MIN_ZOOM = 1e-25;
  const MAX_ZOOM = 1e25;

  let currentTool = "brush";

  toggleToolList.addEventListener("click", () => {
    if (toolDropdownContent.style.display === "block") {
      toolDropdownContent.style.display = "none";
      toolDropdownContent.setAttribute("aria-hidden", "true");
    } else {
      toolDropdownContent.style.display = "block";
      toolDropdownContent.setAttribute("aria-hidden", "false");
    }
  });

  window.addEventListener("click", (e) => {
    if (!toggleToolList.contains(e.target) && !toolDropdownContent.contains(e.target)) {
      toolDropdownContent.style.display = "none";
      toolDropdownContent.setAttribute("aria-hidden", "true");
    }
  });

  toolDropdownContent.querySelectorAll("button").forEach(btn => {
    btn.addEventListener("click", () => {
      currentTool = btn.getAttribute("data-tool");
      toolDropdownContent.style.display = "none";
      toolDropdownContent.setAttribute("aria-hidden", "true");
      console.log("تم اختيار الأداة:", currentTool);
    });
  });

  function updateZoomInfo() {
    if (zoom < 0.0001 || zoom > 10000) {
      zoomInfo.textContent = `زوم: ${zoom.toExponential(2)}x`;
    } else {
      zoomInfo.textContent = `زوم: ${zoom.toFixed(zoom >= 1 ? 2 : 8)}x`;
    }
  }

  // مساعدة: رسم نقطة مربعة (بكسل) بحجم ولون
  function drawPixel(x, y, size, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x - size/2, y - size/2, size, size);
  }

  // مساعدة: تأثير رشاش (airbrush)
  function airbrushEffect(x, y, size, color) {
    const density = 15;
    ctx.fillStyle = color;
    ctx.globalAlpha = 0.04;
    for(let i=0; i<density; i++) {
      const offsetX = (Math.random() - 0.5) * size * 2;
      const offsetY = (Math.random() - 0.5) * size * 2;
      ctx.beginPath();
      ctx.arc(x + offsetX, y + offsetY, size/5, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  // مساعدة: تأثير الدمج البسيط (blender)
  function blendEffect(x, y, size) {
    const gradient = ctx.createRadialGradient(x, y, size*0.3, x, y, size);
    gradient.addColorStop(0, 'rgba(255,255,255,0.7)');
    gradient.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(x, y, size, 0, Math.PI * 2);
    ctx.fill();
  }

  // تعبئة Flood Fill
  function floodFill(startX, startY, fillColor) {
    const imgData = ctx.getImageData(0,0,canvas.width,canvas.height);
    const data = imgData.data;
    const width = imgData.width;
    const height = imgData.height;

    function matchColor(x,y,color) {
      const index = (y * width + x) * 4;
      return (
        data[index] === color[0] &&
        data[index+1] === color[1] &&
        data[index+2] === color[2] &&
        data[index+3] === color[3]
      );
    }

    function setColor(x,y,color) {
      const index = (y * width + x) * 4;
      data[index] = color[0];
      data[index+1] = color[1];
      data[index+2] = color[2];
      data[index+3] = color[3];
    }

    const startPos = (Math.floor(startY) * width + Math.floor(startX)) * 4;
    const startColor = [data[startPos], data[startPos+1], data[startPos+2], data[startPos+3]];

    const fillColRGBA = hexToRgba(fillColor);

    if (arraysEqual(startColor, fillColRGBA)) return; 

    let stack = [[Math.floor(startX), Math.floor(startY)]];

    while(stack.length > 0) {
      const [x,y] = stack.pop();
      if(x < 0 || x >= width || y < 0 || y >= height) continue;
      if(matchColor(x,y,startColor)) {
        setColor(x,y,fillColRGBA);
        stack.push([x+1,y],[x-1,y],[x,y+1],[x,y-1]);
      }
    }
    ctx.putImageData(imgData, 0, 0);
  }

  function hexToRgba(hex) {
    hex = hex.replace('#','');
    if(hex.length === 3) {
      hex = hex.split('').map(c => c+c).join('');
    }
    const bigint = parseInt(hex,16);
    return [
      (bigint >> 16) & 255,
      (bigint >> 8) & 255,
      bigint & 255,
      255
    ];
  }
  function arraysEqual(a,b) {
    if(a.length !== b.length) return false;
    for(let i=0; i<a.length; i++) {
      if(a[i] !== b[i]) return false;
    }
    return true;
  }

  // رسم قطعة مسار بين نقطتين بناءً على الأداة
  function drawPathSegment(lastX, lastY, pos) {
    switch(currentTool) {
      case "highlighter":
        ctx.strokeStyle = currentPath.color;
        ctx.globalAlpha = 0.3;
        ctx.lineWidth = currentPath.size * 3;
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
        ctx.globalAlpha = 1;
        break;

      case "pencil":
        ctx.strokeStyle = currentPath.color;
        ctx.globalAlpha = 0.6;
        ctx.lineWidth = Math.max(1, currentPath.size / 3);
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
        ctx.globalAlpha = 1;
        break;

      case "fountainPen":
        ctx.strokeStyle = currentPath.color;
        ctx.lineWidth = currentPath.size * 1.5;
        ctx.lineCap = "round";
        ctx.shadowColor = currentPath.color;
        ctx.shadowBlur = 1;
        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
        ctx.shadowBlur = 0;
        break;

      case "airbrush":
        airbrushEffect(pos.x, pos.y, currentPath.size, currentPath.color);
        break;

      case "eraser":
        ctx.clearRect(pos.x - currentPath.size/2, pos.y - currentPath.size/2, currentPath.size, currentPath.size);
        break;

      case "softEraser":
        ctx.fillStyle = "rgba(255,255,255,0.3)";
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, currentPath.size/2, 0, Math.PI * 2);
        ctx.fill();
        break;

      case "blender":
        blendEffect(pos.x, pos.y, currentPath.size);
        break;

      case "glowpen":
        ctx.strokeStyle = currentPath.color;
        ctx.lineWidth = currentPath.size;
        ctx.shadowColor = currentPath.color;
        ctx.shadowBlur = 15;
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
        ctx.shadowBlur = 0;
        break;

      case "pixelpen":
        drawPixel(pos.x, pos.y, currentPath.size, currentPath.color);
        break;

      case "line":
        // لا يرسم أثناء السحب، الرسم يتم عند الانتهاء فقط
        break;

      case "fill":
        // fill ليس أداة للرسم بين نقطتين بل تعبئة
        break;

      default: // brush
        ctx.strokeStyle = currentPath.color;
        ctx.lineWidth = currentPath.size;
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
    }
  }

  // إعادة رسم كل المسارات المخزنة
  function drawAll() {
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.setTransform(zoom, 0, 0, zoom, panX, panY);

    for (let path of paths) {
      ctx.strokeStyle = path.color;
      ctx.lineWidth = path.size;
      ctx.lineCap = "round";
      ctx.lineJoin = "round";

      if(path.tool === "line") {
        if(path.points.length >= 2) {
          ctx.beginPath();
          ctx.moveTo(path.points[0].x, path.points[0].y);
          ctx.lineTo(path.points[path.points.length-1].x, path.points[path.points.length-1].y);
          ctx.stroke();
        }
      } else if(path.tool === "pixelpen") {
        for(let pt of path.points) {
          drawPixel(pt.x, pt.y, path.size, path.color);
        }
      } else if(path.tool === "highlighter") {
        ctx.globalAlpha = 0.3;
        ctx.beginPath();
        for(let i=0; i<path.points.length-1; i++) {
          ctx.moveTo(path.points[i].x, path.points[i].y);
          ctx.lineTo(path.points[i+1].x, path.points[i+1].y);
        }
        ctx.stroke();
        ctx.globalAlpha = 1;
      } else if(path.tool === "softEraser") {
        ctx.fillStyle = "rgba(255,255,255,0.3)";
        for(let pt of path.points) {
          ctx.beginPath();
          ctx.arc(pt.x, pt.y, path.size/2, 0, Math.PI*2);
          ctx.fill();
        }
      } else if(path.tool === "blender") {
        for(let pt of path.points) {
          blendEffect(pt.x, pt.y, path.size);
        }
      } else if(path.tool === "airbrush") {
        for(let pt of path.points) {
          airbrushEffect(pt
