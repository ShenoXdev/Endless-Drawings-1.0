<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>تطبيق الرسم المتقدم</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      touch-action: none;
      background: #222;
      font-family: Arial, sans-serif;
    }
    .toolbar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      display: flex;
      padding: 8px;
      background: rgba(40, 40, 40, 0.9);
      z-index: 100;
      gap: 6px;
      flex-wrap: wrap;
      justify-content: center;
    }
    .toolbar button {
      background: #444;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 8px 12px;
      font-size: 14px;
      min-width: 60px;
    }
    .toolbar input[type="number"] {
      width: 60px;
      background: #333;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 8px;
      text-align: center;
    }
    .toolbar input[type="color"] {
      width: 40px;
      height: 40px;
      border: none;
      background: none;
    }
    canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: white;
      touch-action: none;
    }
    #zoomInfo {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.5);
      color: white;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 12px;
      z-index: 100;
    }
  </style>
</head>
<body>
  <div id="zoomInfo">مستوى التكبير: 1x</div>

  <canvas id="canvas"></canvas>

  <div class="toolbar">
    <button onclick="setTool('brush')">✏️ فرشاة</button>
    <button onclick="setTool('eraser')">🧽 ممحاة</button>
    <input type="color" id="colorPicker" value="#000000" onchange="changeColor(this.value)">
    <input type="number" id="sizeInput" min="1" value="5" step="1">
    <button onclick="undo()">↩️ تراجع</button>
    <button onclick="redo()">↪️ إعادة</button>
    <button onclick="clearCanvas()">🗑️ مسح</button>
    <button onclick="save()">💾 حفظ</button>
    <input type="file" id="fileInput" accept=".json">
  </div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const sizeInput = document.getElementById("sizeInput");
    const colorPicker = document.getElementById("colorPicker");
    const zoomInfo = document.getElementById("zoomInfo");
    const fileInput = document.getElementById("fileInput");

    // إعدادات الرسم
    let tool = "brush";
    let drawing = false;
    let baseBrushSize = parseInt(sizeInput.value);
    let brushColor = colorPicker.value;
    
    // إعدادات الكاميرا
    let offsetX = 0;
    let offsetY = 0;
    let scale = 1;
    const MIN_ZOOM = 0.000000000000000000000001;
    const MAX_ZOOM = 100;
    
    // تخزين المسارات والتحكم
    let paths = [];
    let history = [];
    let historyIndex = -1;
    let currentPath = [];
    
    // متغيرات التحكم باللمس
    let touchCount = 0;

    function init() {
      resizeCanvas();
      setupEventListeners();
      saveHistory();
      redraw();
    }

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      redraw();
    }

    function setupEventListeners() {
      window.addEventListener("resize", resizeCanvas);
      
      // أحداث اللمس
      canvas.addEventListener("touchstart", handleTouchStart, { passive: false });
      canvas.addEventListener("touchmove", handleTouchMove, { passive: false });
      canvas.addEventListener("touchend", handleTouchEnd);
      
      // أحداث الماوس (للتجربة على الحاسوب)
      canvas.addEventListener("mousedown", handleMouseDown);
      canvas.addEventListener("mousemove", handleMouseMove);
      canvas.addEventListener("mouseup", handleMouseUp);
      canvas.addEventListener("wheel", handleWheel, { passive: false });
      
      // التحكم بحجم الفرشاة
      sizeInput.addEventListener("input", () => {
        baseBrushSize = parseInt(sizeInput.value);
      });
    }

    function getTouchPos(touch) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: touch.clientX - rect.left,
        y: touch.clientY - rect.top
      };
    }

    function handleTouchStart(e) {
      touchCount = e.touches.length;
      
      // الرسم بإصبع واحد فقط
      if (touchCount === 1) {
        e.preventDefault();
        const pos = getTouchPos(e.touches[0]);
        startDraw(pos.x, pos.y);
      } else {
        // إذا كان هناك أكثر من إصبع، نوقف الرسم الحالي
        if (drawing) {
          endDraw();
          drawing = false;
        }
      }
    }

    function handleTouchMove(e) {
      touchCount = e.touches.length;
      
      // الرسم بإصبع واحد فقط
      if (touchCount === 1 && drawing) {
        e.preventDefault();
        const pos = getTouchPos(e.touches[0]);
        draw(pos.x, pos.y);
      }
    }

    function handleTouchEnd(e) {
      if (drawing) endDraw();
      touchCount = e.touches.length;
    }

    function handleMouseDown(e) {
      startDraw(e.clientX, e.clientY);
    }

    function handleMouseMove(e) {
      draw(e.clientX, e.clientY);
    }

    function handleMouseUp() {
      endDraw();
    }

    function handleWheel(e) {
      e.preventDefault();
      const zoomFactor = Math.exp(-e.deltaY * 0.001);
      const rect = canvas.getBoundingClientRect();
      handleZoom(e.clientX - rect.left, e.clientY - rect.top, zoomFactor);
    }

    function handleZoom(centerX, centerY, zoomFactor) {
      const wx = (centerX - offsetX) / scale;
      const wy = (centerY - offsetY) / scale;
      scale *= zoomFactor;
      scale = Math.max(MIN_ZOOM, Math.min(scale, MAX_ZOOM));
      offsetX = centerX - wx * scale;
      offsetY = centerY - wy * scale;
      updateZoomInfo();
      redraw();
    }

    function setTool(t) { tool = t; }
    function changeColor(color) { brushColor = color; }
    function screenToWorld(x, y) { return [(x - offsetX) / scale, (y - offsetY) / scale]; }
    function worldToScreen(x, y) { return [x * scale + offsetX, y * scale + offsetY]; }
    function getCurrentBrushSize() { return baseBrushSize / Math.sqrt(scale); }

    function startDraw(x, y) {
      if (touchCount > 1) return; // لا نرسم إذا كان هناك أكثر من إصبع
      
      const [wx, wy] = screenToWorld(x, y);
      currentPath = [{
        x: wx,
        y: wy,
        tool,
        size: getCurrentBrushSize(),
        color: tool === "brush" ? brushColor : "white"
      }];
      drawing = true;
    }

    function draw(x, y) {
      if (!drawing || touchCount > 1) return; // لا نرسم إذا كان هناك أكثر من إصبع
      
      const [wx, wy] = screenToWorld(x, y);
      currentPath.push({
        x: wx,
        y: wy,
        tool,
        size: getCurrentBrushSize(),
        color: tool === "brush" ? brushColor : "white"
      });
      redraw();
    }

    function endDraw() {
      if (drawing && currentPath.length > 1) {
        paths.push(currentPath);
        saveHistory();
      }
      drawing = false;
    }

    function redraw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      for (const path of paths) {
        ctx.beginPath();
        for (let i = 0; i < path.length; i++) {
          const p = path[i];
          const [sx, sy] = worldToScreen(p.x, p.y);
          ctx.lineWidth = p.size * scale;
          ctx.strokeStyle = p.color;
          ctx.lineCap = "round";
          ctx.lineJoin = "round";
          if (i === 0) ctx.moveTo(sx, sy);
          else ctx.lineTo(sx, sy);
        }
        ctx.stroke();
      }
      
      if (drawing && currentPath.length > 0) {
        ctx.beginPath();
        for (let i = 0; i < currentPath.length; i++) {
          const p = currentPath[i];
          const [sx, sy] = worldToScreen(p.x, p.y);
          ctx.lineWidth = p.size * scale;
          ctx.strokeStyle = p.color;
          ctx.lineCap = "round";
          ctx.lineJoin = "round";
          if (i === 0) ctx.moveTo(sx, sy);
          else ctx.lineTo(sx, sy);
        }
        ctx.stroke();
      }
    }

    function updateZoomInfo() {
      zoomInfo.textContent = `مستوى التكبير: ${scale.toFixed(2)}x`;
    }

    function saveHistory() {
      history.splice(historyIndex + 1);
      history.push(JSON.stringify({
        paths: JSON.parse(JSON.stringify(paths)),
        camera: { offsetX, offsetY, scale },
        brush: { baseBrushSize, brushColor }
      }));
      historyIndex++;
    }

    function undo() {
      if (historyIndex > 0) {
        historyIndex--;
        loadStateFromHistory();
      }
    }

    function redo() {
      if (historyIndex < history.length - 1) {
        historyIndex++;
        loadStateFromHistory();
      }
    }

    function loadStateFromHistory() {
      try {
        const state = JSON.parse(history[historyIndex]);
        paths = state.paths || [];
        offsetX = state.camera?.offsetX || 0;
        offsetY = state.camera?.offsetY || 0;
        scale = state.camera?.scale || 1;
        if (state.brush) {
          baseBrushSize = state.brush.baseBrushSize || 5;
          brushColor = state.brush.brushColor || "#000000";
          colorPicker.value = brushColor;
          sizeInput.value = baseBrushSize;
        }
        redraw();
        updateZoomInfo();
      } catch (error) {
        console.error("Error loading state:", error);
      }
    }

    function clearCanvas() {
      if (confirm("هل تريد مسح اللوحة بالكامل؟")) {
        paths = [];
        saveHistory();
        redraw();
      }
    }

    function save() {
      const data = {
        paths: JSON.parse(JSON.stringify(paths)),
        camera: { offsetX, offsetY, scale },
        brush: { baseBrushSize, brushColor }
      };
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const link = document.createElement("a");
      link.download = `رسمة-${new Date().toISOString().slice(0, 19)}.json`;
      link.href = URL.createObjectURL(blob);
      link.click();
    }

    function openFileDialog() {
      fileInput.click();
    }

    function handleFileSelect(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const data = JSON.parse(e.target.result);
          if (!data || !Array.isArray(data.paths)) throw new Error("تنسيق الملف غير صالح");
          
          paths = JSON.parse(JSON.stringify(data.paths));
          offsetX = data.camera?.offsetX || 0;
          offsetY = data.camera?.offsetY || 0;
          scale = data.camera?.scale || 1;
          
          if (data.brush) {
            baseBrushSize = data.brush.baseBrushSize || 5;
            brushColor = data.brush.brushColor || "#000000";
            colorPicker.value = brushColor;
            sizeInput.value = baseBrushSize;
          }
          
          history = [JSON.stringify({
            paths: JSON.parse(JSON.stringify(paths)),
            camera: { offsetX, offsetY, scale },
            brush: { baseBrushSize, brushColor }
          })];
          historyIndex = 0;
          
          redraw();
          updateZoomInfo();
          alert("تم تحميل الرسم بنجاح");
        } catch (error) {
          alert(`خطأ في تحميل الملف: ${error.message}`);
        }
      };
      reader.onerror = function() {
        alert("حدث خطأ أثناء قراءة الملف");
      };
      reader.readAsText(file);
    }

    // بدء التطبيق
    init();
  </script>
</body>
</html>
