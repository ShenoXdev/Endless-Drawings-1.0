<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>تطبيق الرسم المتقدم</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      touch-action: none;
      background: #222;
      font-family: Arial, sans-serif;
    }
    
    .toolbar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      display: flex;
      padding: 8px;
      background: rgba(40, 40, 40, 0.9);
      z-index: 100;
      gap: 6px;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    .toolbar button {
      background: #444;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 8px 12px;
      font-size: 14px;
      min-width: 60px;
    }
    
    .toolbar input[type="number"] {
      width: 60px;
      background: #333;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 8px;
      text-align: center;
    }
    
    .toolbar input[type="color"] {
      width: 40px;
      height: 40px;
      border: none;
      background: none;
    }
    
    canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: white;
      touch-action: none;
    }
    
    #zoomInfo {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.5);
      color: white;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 12px;
      z-index: 100;
    }
    
    #controlsInfo {
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.5);
      color: white;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 12px;
      z-index: 100;
    }
    
    #fileInput {
      display: none;
    }
    
    @media (max-width: 768px) {
      #controlsInfo {
        display: none;
      }
    }
  </style>
</head>
<body>
  <div id="zoomInfo">مستوى التكبير: 1x</div>
  <div id="controlsInfo">
    تحكمات لوحة المفاتيح: <br>
    WASD: حركة | Q/E: تكبير/تصغير | B: فرشاة | X: ممحاة<br>
    1/2/3: أحجام الفرشاة | Space: تحريك | Ctrl+Z/Y: تراجع/إعادة
  </div>
  
  <canvas id="canvas"></canvas>
  
  <div class="toolbar">
    <button onclick="setTool('brush')">✏️ فرشاة</button>
    <button onclick="setTool('eraser')">🧽 ممحاة</button>
    <input type="color" id="colorPicker" value="#000000" onchange="changeColor(this.value)">
    <input type="number" id="sizeInput" min="1" value="5" step="1">
    <button onclick="undo()">↩️ تراجع</button>
    <button onclick="redo()">↪️ إعادة</button>
    <button onclick="clearCanvas()">🗑️ مسح</button>
    <button onclick="save()">💾 حفظ</button>
    <button onclick="openFileDialog()">📂 فتح</button>
    <input type="file" id="fileInput" accept=".json" style="display:none">
  </div>

  <script>
    // العناصر الرئيسية
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const sizeInput = document.getElementById("sizeInput");
    const colorPicker = document.getElementById("colorPicker");
    const zoomInfo = document.getElementById("zoomInfo");
    const fileInput = document.getElementById("fileInput");
    
    // حالة التطبيق
    let tool = "brush";
    let drawing = false;
    let baseBrushSize = parseInt(sizeInput.value);
    let brushColor = colorPicker.value;
    let offsetX = 0;
    let offsetY = 0;
    let scale = 1;
    let paths = [];
    let history = [];
    let historyIndex = -1;
    let currentPath = [];
    let isPanning = false;
    let panStart = { x: 0, y: 0 };
    
    // تحكمات لوحة المفاتيح
    const keys = {};
    const PAN_SPEED = 10;
    const ZOOM_SPEED = 0.05;
    const MIN_ZOOM = 0.000000000000000000000001;
    const MAX_ZOOM = 1000000;

    // تهيئة التطبيق
    function init() {
      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);
      fileInput.addEventListener("change", handleFileSelect);
      setupEventListeners();
      animationLoop();
      saveHistory();
    }

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      redraw();
    }

    function setupEventListeners() {
      // لوحة المفاتيح
      window.addEventListener("keydown", (e) => {
        keys[e.key.toLowerCase()] = true;
        if (e.ctrlKey) {
          if (e.key === 'z') undo();
          if (e.key === 'y') redo();
        }
      });
      
      window.addEventListener("keyup", (e) => {
        keys[e.key.toLowerCase()] = false;
      });
      
      // الفأرة
      canvas.addEventListener("mousedown", handleMouseDown);
      canvas.addEventListener("mousemove", handleMouseMove);
      canvas.addEventListener("mouseup", handleMouseUp);
      canvas.addEventListener("wheel", handleWheel, { passive: false });
      
      // شريط الأدوات
      sizeInput.addEventListener("input", () => {
        baseBrushSize = parseInt(sizeInput.value);
      });
    }

    function handleKeyboardControls() {
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      
      // الحركة
      if (keys['w'] || keys['arrowup']) offsetY -= PAN_SPEED / scale;
      if (keys['s'] || keys['arrowdown']) offsetY += PAN_SPEED / scale;
      if (keys['a'] || keys['arrowleft']) offsetX -= PAN_SPEED / scale;
      if (keys['d'] || keys['arrowright']) offsetX += PAN_SPEED / scale;
      
      // التكبير/التصغير
      if (keys['q']) handleZoom(centerX, centerY, 1 - ZOOM_SPEED);
      if (keys['e']) handleZoom(centerX, centerY, 1 + ZOOM_SPEED);
      
      // الأدوات
      if (keys['b']) setTool('brush');
      if (keys['x']) setTool('eraser');
      
      // أحجام الفرشاة
      if (keys['1']) baseBrushSize = 1;
      if (keys['2']) baseBrushSize = 5;
      if (keys['3']) baseBrushSize = 10;
      
      // التحريك
      isPanning = keys[' '];
      
      if (keys['w'] || keys['s'] || keys['a'] || keys['d'] || keys['q'] || keys['e']) {
        redraw();
      }
    }

    function animationLoop() {
      handleKeyboardControls();
      requestAnimationFrame(animationLoop);
    }

    function setTool(t) {
      tool = t;
    }
    
    function changeColor(color) {
      brushColor = color;
    }
    
    function screenToWorld(x, y) {
      return [(x - offsetX) / scale, (y - offsetY) / scale];
    }
    
    function worldToScreen(x, y) {
      return [x * scale + offsetX, y * scale + offsetY];
    }
    
    function getCurrentBrushSize() {
      return baseBrushSize / Math.sqrt(scale);
    }
    
    function handleMouseDown(e) {
      if (e.button === 1 || e.ctrlKey) {
        isPanning = true;
        panStart = { x: e.clientX, y: e.clientY };
      } else {
        startDraw(e.clientX, e.clientY);
      }
    }
    
    function startDraw(x, y) {
      if (isPanning) return;
      const [wx, wy] = screenToWorld(x, y);
      currentPath = [{
        x: wx,
        y: wy,
        tool,
        size: getCurrentBrushSize(),
        color: tool === "brush" ? brushColor : "white"
      }];
      drawing = true;
    }
    
    function handleMouseMove(e) {
      if (isPanning) {
        offsetX += e.clientX - panStart.x;
        offsetY += e.clientY - panStart.y;
        panStart = { x: e.clientX, y: e.clientY };
        redraw();
      } else {
        draw(e.clientX, e.clientY);
      }
    }
    
    function draw(x, y) {
      if (!drawing || isPanning) return;
      
      const [wx, wy] = screenToWorld(x, y);
      currentPath.push({
        x: wx,
        y: wy,
        tool,
        size: getCurrentBrushSize(),
        color: tool === "brush" ? brushColor : "white"
      });
      
      redraw();
    }
    
    function handleMouseUp(e) {
      if (isPanning) {
        isPanning = false;
      } else {
        endDraw();
      }
    }
    
    function endDraw() {
      if (drawing && currentPath.length > 1) {
        paths.push(currentPath);
        saveHistory();
      }
      drawing = false;
    }
    
    function handleWheel(e) {
      e.preventDefault();
      const zoomFactor = Math.exp(-e.deltaY * 0.001);
      const rect = canvas.getBoundingClientRect();
      handleZoom(e.clientX - rect.left, e.clientY - rect.top, zoomFactor);
    }
    
    function handleZoom(centerX, centerY, zoomFactor) {
      const wx = (centerX - offsetX) / scale;
      const wy = (centerY - offsetY) / scale;
      
      scale *= zoomFactor;
      scale = Math.max(MIN_ZOOM, Math.min(scale, MAX_ZOOM));
      
      offsetX = centerX - wx * scale;
      offsetY = centerY - wy * scale;
      
      updateZoomInfo();
      redraw();
    }
    
    function redraw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      for (const path of paths) {
        ctx.beginPath();
        for (let i = 0; i < path.length; i++) {
          const p = path[i];
          const [sx, sy] = worldToScreen(p.x, p.y);
          ctx.lineWidth = p.size * scale;
          ctx.strokeStyle = p.color;
          ctx.lineCap = "round";
          ctx.lineJoin = "round";
          
          if (i === 0) ctx.moveTo(sx, sy);
          else ctx.lineTo(sx, sy);
        }
        ctx.stroke();
      }
      
      if (drawing && currentPath.length > 0) {
        ctx.beginPath();
        for (let i = 0; i < currentPath.length; i++) {
          const p = currentPath[i];
          const [sx, sy] = worldToScreen(p.x, p.y);
          ctx.lineWidth = p.size * scale;
          ctx.strokeStyle = p.color;
          ctx.lineCap = "round";
          ctx.lineJoin = "round";
          
          if (i === 0) ctx.moveTo(sx, sy);
          else ctx.lineTo(sx, sy);
        }
        ctx.stroke();
      }
    }
    
    function saveHistory() {
      history.splice(historyIndex + 1);
      history.push(JSON.stringify({
        paths: JSON.parse(JSON.stringify(paths)),
        camera: { offsetX, offsetY, scale },
        brush: { baseBrushSize, brushColor }
      }));
      historyIndex++;
    }
    
    function undo() {
      if (historyIndex > 0) {
        historyIndex--;
        loadStateFromHistory();
      }
    }
    
    function redo() {
      if (historyIndex < history.length - 1) {
        historyIndex++;
        loadStateFromHistory();
      }
    }
    
    function loadStateFromHistory() {
      try {
        const state = JSON.parse(history[historyIndex]);
        paths = state.paths || [];
        offsetX = state.camera?.offsetX || 0;
        offsetY = state.camera?.offsetY || 0;
        scale = state.camera?.scale || 1;
        
        if (state.brush) {
          baseBrushSize = state.brush.baseBrushSize || 5;
          brushColor = state.brush.brushColor || "#000000";
          colorPicker.value = brushColor;
          sizeInput.value = baseBrushSize;
        }
        
        redraw();
        updateZoomInfo();
      } catch (error) {
        console.error("Error loading state:", error);
      }
    }
    
    function clearCanvas() {
      if (confirm("هل تريد مسح اللوحة بالكامل؟")) {
        paths = [];
        saveHistory();
        redraw();
      }
    }
    
    function save() {
      const data = {
        paths: JSON.parse(JSON.stringify(paths)),
        camera: { offsetX, offsetY, scale },
        brush: { baseBrushSize, brushColor }
      };
      
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const link = document.createElement("a");
      link.download = `رسمة-${new Date().toISOString().slice(0, 19)}.json`;
      link.href = URL.createObjectURL(blob);
      link.click();
    }
    
    function openFileDialog() {
      fileInput.click();
    }
    
    function handleFileSelect(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const data = JSON.parse(e.target.result);
          
          if (!data || !Array.isArray(data.paths)) {
            throw new Error("تنسيق الملف غير صالح");
          }
          
          paths = JSON.parse(JSON.stringify(data.paths));
          offsetX = data.camera?.offsetX || 0;
          offsetY = data.camera?.offsetY || 0;
          scale = data.camera?.scale || 1;
          
          if (data.brush) {
            baseBrushSize = data.brush.baseBrushSize || 5;
            brushColor = data.brush.brushColor || "#000000";
            colorPicker.value = brushColor;
            sizeInput.value = baseBrushSize;
          }
          
          history = [JSON.stringify({
            paths: JSON.parse(JSON.stringify(paths)),
            camera: { offsetX, offsetY, scale },
            brush: { baseBrushSize, brushColor }
          })];
          historyIndex = 0;
          
          redraw();
          updateZoomInfo();
          alert("تم تحميل الرسم بنجاح");
        } catch (error) {
          alert(`خطأ في تحميل الملف: ${error.message}`);
          console.error("Error loading file:", error);
        }
      };
      
      reader.onerror = function() {
        alert("حدث خطأ أثناء قراءة الملف");
      };
      
      reader.readAsText(file);
    }
    
    function updateZoomInfo() {
      zoomInfo.textContent = `مستوى التكبير: ${scale.toFixed(2)}x`;
    }

    // بدء تشغيل التطبيق
    init();
  </script>
</body>
</html>