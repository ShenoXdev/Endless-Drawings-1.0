<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Infinite Canvas Drawing</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      touch-action: none;
    }
    #canvas {
      position: absolute;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      touch-action: none;
    }
    #toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255, 255, 255, 0.8);
      padding: 8px;
      border-radius: 8px;
      z-index: 10;
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="toolbar">
    <button id="undoBtn">Undo</button>
    <button id="redoBtn">Redo</button>
    <button id="newBtn">New</button>
    <button id="eraseBtn">Eraser</button>
    <input type="color" id="colorPicker">
    <button id="increaseBtn">+</button>
    <button id="decreaseBtn">-</button>
    <input type="number" id="sizeInput" min="1" max="1e+23" value="5" step="1">
    <span id="zoomInfo">Zoom: 1x</span>
  </div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const undoBtn = document.getElementById("undoBtn");
    const redoBtn = document.getElementById("redoBtn");
    const newBtn = document.getElementById("newBtn");
    const eraseBtn = document.getElementById("eraseBtn");
    const colorPicker = document.getElementById("colorPicker");
    const increaseBtn = document.getElementById("increaseBtn");
    const decreaseBtn = document.getElementById("decreaseBtn");
    const sizeInput = document.getElementById("sizeInput");
    const zoomInfo = document.getElementById("zoomInfo");

    let drawing = false;
    let erasing = false;
    let scale = 1;
    let camera = { x: 0, y: 0 };
    let baseBrushSize = 5;
    let color = "#000000";
    let undoStack = [];
    let redoStack = [];

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    function saveState() {
      undoStack.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
      redoStack = [];
    }

    function restoreState(stackFrom, stackTo) {
      if (stackFrom.length > 0) {
        stackTo.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
        const imageData = stackFrom.pop();
        ctx.putImageData(imageData, 0, 0);
      }
    }

    function clearCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    function getCurrentBrushSize() {
      return Math.min(baseBrushSize / Math.sqrt(scale), 1e+23);
    }

    function screenToWorld(x, y) {
      return {
        x: (x - canvas.width / 2) / scale + camera.x,
        y: (y - canvas.height / 2) / scale + camera.y
      };
    }

    function drawLine(from, to) {
      ctx.strokeStyle = erasing ? "#ffffff" : color;
      ctx.lineWidth = getCurrentBrushSize();
      ctx.lineCap = "round";
      ctx.beginPath();
      ctx.moveTo(from.x, from.y);
      ctx.lineTo(to.x, to.y);
      ctx.stroke();
    }

    let lastTouch = null;

    canvas.addEventListener("touchstart", (e) => {
      if (e.touches.length === 1) {
        const touch = e.touches[0];
        lastTouch = screenToWorld(touch.clientX, touch.clientY);
        drawing = true;
        saveState();
      }
    });

    canvas.addEventListener("touchmove", (e) => {
      e.preventDefault();
      if (e.touches.length === 1 && drawing) {
        const touch = e.touches[0];
        const current = screenToWorld(touch.clientX, touch.clientY);
        drawLine(lastTouch, current);
        lastTouch = current;
      } else if (e.touches.length === 2) {
        const t0 = e.touches[0];
        const t1 = e.touches[1];

        const dx = t1.clientX - t0.clientX;
        const dy = t1.clientY - t0.clientY;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (!canvas._lastDist) canvas._lastDist = dist;
        const zoomFactor = dist / canvas._lastDist;
        canvas._lastDist = dist;

        // Fix center
        const centerX = (t0.clientX + t1.clientX) / 2;
        const centerY = (t0.clientY + t1.clientY) / 2;
        const worldBefore = screenToWorld(centerX, centerY);

        scale *= zoomFactor;

        const worldAfter = screenToWorld(centerX, centerY);
        camera.x += worldBefore.x - worldAfter.x;
        camera.y += worldBefore.y - worldAfter.y;

        zoomInfo.textContent = `Zoom: ${scale.toFixed(2)}x`;
      } else if (e.touches.length === 3) {
        // Three fingers pan
        const avgX = Array.from(e.touches).reduce((sum, t) => sum + t.clientX, 0) / 3;
        const avgY = Array.from(e.touches).reduce((sum, t) => sum + t.clientY, 0) / 3;

        if (!canvas._lastPan) canvas._lastPan = { x: avgX, y: avgY };

        const dx = (canvas._lastPan.x - avgX) / scale;
        const dy = (canvas._lastPan.y - avgY) / scale;

        camera.x += dx;
        camera.y += dy;
        canvas._lastPan = { x: avgX, y: avgY };
      }
    });

    canvas.addEventListener("touchend", (e) => {
      if (e.touches.length === 0) {
        drawing = false;
        canvas._lastDist = null;
        canvas._lastPan = null;
      }
    });

    function redraw() {
      const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      clearCanvas();
      ctx.save();
      ctx.translate(canvas.width / 2, canvas.height / 2);
      ctx.scale(scale, scale);
      ctx.translate(-camera.x, -camera.y);
      ctx.putImageData(imgData, 0, 0);
      ctx.restore();
    }

    colorPicker.addEventListener("input", (e) => color = e.target.value);
    eraseBtn.addEventListener("click", () => erasing = !erasing);
    increaseBtn.addEventListener("click", () => {
      baseBrushSize *= 2;
      sizeInput.value = baseBrushSize;
    });
    decreaseBtn.addEventListener("click", () => {
      baseBrushSize = Math.max(1, baseBrushSize / 2);
      sizeInput.value = baseBrushSize;
    });
    sizeInput.addEventListener("input", () => {
      baseBrushSize = Math.min(parseFloat(sizeInput.value), 1e+23);
    });
    undoBtn.addEventListener("click", () => restoreState(undoStack, redoStack));
    redoBtn.addEventListener("click", () => restoreState(redoStack, undoStack));
    newBtn.addEventListener("click", () => {
      saveState();
      clearCanvas();
    });

    window.addEventListener("resize", () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    });
  </script>
</body>
</html>
