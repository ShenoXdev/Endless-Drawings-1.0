<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Infinite Canvas Drawing</title>
  <style>
    html, body {
      margin: 0; padding: 0; height: 100%; overflow: hidden;
    }
    canvas {
      touch-action: none;
      display: block;
      background: white;
    }
    #ui {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(255, 255, 255, 0.8);
      padding: 5px;
      border-radius: 8px;
      z-index: 10;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="ui">
    <label>Brush Size: <input type="number" id="sizeInput" min="1" max="1e+23" value="5" step="1"></label>
  </div>
  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const sizeInput = document.getElementById("sizeInput");

    let width = window.innerWidth;
    let height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    let offsetX = 0;
    let offsetY = 0;
    let scale = 1;
    const MIN_ZOOM = 0.000000000000000000000001;
    const MAX_ZOOM = 100000;

    let baseBrushSize = parseFloat(sizeInput.value);
    let currentPath = [];
    let drawing = false;
    let tool = "brush";
    let brushColor = "black";

    let isPanning = false;
    let initialDistance = 0;
    let initialScale = 1;
    let initialMidpoint = null;
    let touchCount = 0;

    const paths = [];

    function getCurrentBrushSize() {
      return Math.min(baseBrushSize / Math.sqrt(scale), 1e+23);
    }

    sizeInput.addEventListener("input", () => {
      let val = parseFloat(sizeInput.value);
      if (val > 1e+23) val = 1e+23;
      baseBrushSize = val;
      sizeInput.value = baseBrushSize;
    });

    function screenToWorld(x, y) {
      return [(x - offsetX) / scale, (y - offsetY) / scale];
    }

    function startDraw(x, y) {
      if (touchCount > 1) return; // لا ترسم وقت الزوم/البان
      const [wx, wy] = screenToWorld(x, y);
      currentPath = [{
        x: wx,
        y: wy,
        tool,
        size: getCurrentBrushSize(),
        color: tool === "brush" ? brushColor : "white"
      }];
      drawing = true;
    }

    function draw(x, y) {
      if (!drawing) return;
      const [wx, wy] = screenToWorld(x, y);
      currentPath.push({
        x: wx,
        y: wy,
        tool,
        size: getCurrentBrushSize(),
        color: tool === "brush" ? brushColor : "white"
      });
      redraw();
    }

    function endDraw() {
      if (drawing && currentPath.length > 0) {
        paths.push(currentPath);
      }
      drawing = false;
    }

    function redraw() {
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.setTransform(scale, 0, 0, scale, offsetX, offsetY);
      for (const path of paths) {
        renderPath(path);
      }
      if (currentPath.length > 0) {
        renderPath(currentPath);
      }
    }

    function renderPath(path) {
      if (path.length < 2) return;
      ctx.strokeStyle = path[0].color;
      ctx.lineWidth = path[0].size;
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      ctx.beginPath();
      ctx.moveTo(path[0].x, path[0].y);
      for (let i = 1; i < path.length; i++) {
        ctx.lineTo(path[i].x, path[i].y);
      }
      ctx.stroke();
    }

    function calculateDistance(t1, t2) {
      const dx = t2.clientX - t1.clientX;
      const dy = t2.clientY - t1.clientY;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function calculateMidpoint(t1, t2) {
      return {
        x: (t1.clientX + t2.clientX) / 2,
        y: (t1.clientY + t2.clientY) / 2
      };
    }

    // Mouse support
    canvas.addEventListener("mousedown", e => {
      startDraw(e.clientX, e.clientY);
    });

    canvas.addEventListener("mousemove", e => {
      if (drawing) draw(e.clientX, e.clientY);
    });

    canvas.addEventListener("mouseup", endDraw);
    canvas.addEventListener("mouseleave", endDraw);

    // Touch support
    canvas.addEventListener("touchstart", e => {
      touchCount = e.touches.length;
      if (touchCount === 1) {
        const touch = e.touches[0];
        startDraw(touch.clientX, touch.clientY);
      } else if (touchCount === 2) {
        isPanning = true;
        initialDistance = calculateDistance(e.touches[0], e.touches[1]);
        initialScale = scale;
        initialMidpoint = calculateMidpoint(e.touches[0], e.touches[1]);
      }
    }, { passive: false });

    canvas.addEventListener("touchmove", e => {
      touchCount = e.touches.length;
      if (touchCount === 1 && drawing) {
        e.preventDefault();
        const touch = e.touches[0];
        draw(touch.clientX, touch.clientY);
      } else if (touchCount === 2) {
        e.preventDefault();
        const currentDistance = calculateDistance(e.touches[0], e.touches[1]);
        const currentMidpoint = calculateMidpoint(e.touches[0], e.touches[1]);

        // Zoom
        if (initialDistance > 0) {
          const zoomFactor = currentDistance / initialDistance;
          scale = initialScale * zoomFactor;
          scale = Math.max(MIN_ZOOM, Math.min(scale, MAX_ZOOM));
        }

        // Pan
        if (initialMidpoint) {
          const dx = currentMidpoint.x - initialMidpoint.x;
          const dy = currentMidpoint.y - initialMidpoint.y;
          offsetX += dx;
          offsetY += dy;
          initialMidpoint = currentMidpoint;
        }

        redraw();
      }
    }, { passive: false });

    canvas.addEventListener("touchend", e => {
      touchCount = e.touches.length;
      if (touchCount === 0) {
        endDraw();
        isPanning = false;
      }
    });

    // Resize
    window.addEventListener("resize", () => {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
      redraw();
    });

    redraw();
  </script>
</body>
</html>
