<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Infinite Canvas Drawing</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      touch-action: none;
    }
    #toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255, 255, 255, 0.9);
      padding: 10px;
      border-radius: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      z-index: 10;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <div id="toolbar">
    <button id="undoBtn">Undo</button>
    <button id="redoBtn">Redo</button>
    <button id="newBtn">New</button>
    <button id="eraseBtn">Eraser</button>
    <input type="color" id="colorPicker">
    <button id="increaseBtn">+</button>
    <button id="decreaseBtn">-</button>
    <input type="number" id="sizeInput" min="1" max="100000000000000000000000" value="5" step="1">
    <span id="zoomInfo">Zoom: 1x</span>
  </div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    const undoBtn = document.getElementById("undoBtn");
    const redoBtn = document.getElementById("redoBtn");
    const newBtn = document.getElementById("newBtn");
    const eraseBtn = document.getElementById("eraseBtn");
    const colorPicker = document.getElementById("colorPicker");
    const increaseBtn = document.getElementById("increaseBtn");
    const decreaseBtn = document.getElementById("decreaseBtn");
    const sizeInput = document.getElementById("sizeInput");
    const zoomInfo = document.getElementById("zoomInfo");

    let drawing = false;
    let erasing = false;
    let lastX, lastY;
    let paths = [];
    let undonePaths = [];
    let baseBrushSize = parseFloat(sizeInput.value);
    let currentColor = "#000000";

    let offsetX = 0;
    let offsetY = 0;
    let scale = 1;
    let lastTouches = [];

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      redraw();
    }

    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    function getCurrentBrushSize() {
      return Math.min(baseBrushSize / Math.sqrt(scale), 1e+23);
    }

    function getTransformedPos(x, y) {
      return {
        x: (x - offsetX) / scale,
        y: (y - offsetY) / scale
      };
    }

    function drawLine(x1, y1, x2, y2, color, size) {
      ctx.strokeStyle = color;
      ctx.lineWidth = size;
      ctx.lineCap = "round";
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }

    function redraw() {
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.setTransform(scale, 0, 0, scale, offsetX, offsetY);
      for (let path of paths) {
        drawLine(path.x1, path.y1, path.x2, path.y2, path.color, path.size);
      }
    }

    function startDrawing(x, y) {
      drawing = true;
      const pos = getTransformedPos(x, y);
      lastX = pos.x;
      lastY = pos.y;
    }

    function draw(x, y) {
      if (!drawing) return;
      const pos = getTransformedPos(x, y);
      const size = getCurrentBrushSize();
      const color = erasing ? "#FFFFFF" : currentColor;
      paths.push({ x1: lastX, y1: lastY, x2: pos.x, y2: pos.y, color, size });
      drawLine(lastX, lastY, pos.x, pos.y, color, size);
      lastX = pos.x;
      lastY = pos.y;
    }

    function stopDrawing() {
      drawing = false;
      undonePaths = [];
    }

    canvas.addEventListener("mousedown", e => {
      if (e.buttons === 1) startDrawing(e.clientX, e.clientY);
    });

    canvas.addEventListener("mousemove", e => {
      draw(e.clientX, e.clientY);
    });

    canvas.addEventListener("mouseup", stopDrawing);
    canvas.addEventListener("mouseout", stopDrawing);

    canvas.addEventListener("wheel", e => {
      e.preventDefault();
      const delta = e.deltaY < 0 ? 1.1 : 0.9;
      const mouseX = e.clientX;
      const mouseY = e.clientY;
      const worldX = (mouseX - offsetX) / scale;
      const worldY = (mouseY - offsetY) / scale;
      scale *= delta;
      offsetX = mouseX - worldX * scale;
      offsetY = mouseY - worldY * scale;
      zoomInfo.textContent = `Zoom: ${scale.toFixed(2)}x`;
      redraw();
    });

    canvas.addEventListener("touchstart", e => {
      lastTouches = [...e.touches];
      if (e.touches.length === 1) {
        const t = e.touches[0];
        startDrawing(t.clientX, t.clientY);
      }
    });

    canvas.addEventListener("touchmove", e => {
      e.preventDefault();
      if (e.touches.length === 1) {
        draw(e.touches[0].clientX, e.touches[0].clientY);
      } else if (e.touches.length === 2) {
        // Zoom
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const distance = Math.sqrt(dx * dx + dy * dy);

        const prevDx = lastTouches[0].clientX - lastTouches[1].clientX;
        const prevDy = lastTouches[0].clientY - lastTouches[1].clientY;
        const prevDistance = Math.sqrt(prevDx * prevDx + prevDy * prevDy);

        const delta = distance / prevDistance;
        const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
        const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
        const worldX = (midX - offsetX) / scale;
        const worldY = (midY - offsetY) / scale;
        scale *= delta;
        offsetX = midX - worldX * scale;
        offsetY = midY - worldY * scale;
        zoomInfo.textContent = `Zoom: ${scale.toFixed(2)}x`;
        redraw();
        lastTouches = [...e.touches];
      } else if (e.touches.length === 3) {
        // Pan
        const dx = e.touches[0].clientX - lastTouches[0].clientX;
        const dy = e.touches[0].clientY - lastTouches[0].clientY;
        offsetX += dx;
        offsetY += dy;
        redraw();
        lastTouches = [...e.touches];
      }
    });

    canvas.addEventListener("touchend", e => {
      if (e.touches.length < 1) stopDrawing();
      lastTouches = [...e.touches];
    });

    // UI Buttons
    undoBtn.onclick = () => {
      if (paths.length > 0) {
        undonePaths.push(paths.pop());
        redraw();
      }
    };

    redoBtn.onclick = () => {
      if (undonePaths.length > 0) {
        paths.push(undonePaths.pop());
        redraw();
      }
    };

    newBtn.onclick = () => {
      if (confirm("Clear canvas?")) {
        paths = [];
        undonePaths = [];
        redraw();
      }
    };

    eraseBtn.onclick = () => {
      erasing = !erasing;
      eraseBtn.style.background = erasing ? "#f99" : "";
    };

    colorPicker.oninput = (e) => {
      currentColor = e.target.value;
    };

    increaseBtn.onclick = () => {
      baseBrushSize *= 1.5;
      if (baseBrushSize > 1e+23) baseBrushSize = 1e+23;
      sizeInput.value = baseBrushSize;
    };

    decreaseBtn.onclick = () => {
      baseBrushSize /= 1.5;
      if (baseBrushSize < 1) baseBrushSize = 1;
      sizeInput.value = baseBrushSize;
    };

    sizeInput.addEventListener("input", () => {
      let val = parseFloat(sizeInput.value);
      if (val > 1e+23) val = 1e+23;
      if (val < 1) val = 1;
      baseBrushSize = val;
      sizeInput.value = baseBrushSize;
    });
  </script>
</body>
</html>
