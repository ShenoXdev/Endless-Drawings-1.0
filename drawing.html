<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Infinite Canvas Drawing</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      overflow: hidden;
      touch-action: none;
    }
    canvas {
      display: block;
      background: #fff;
    }
    #toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255, 255, 255, 0.9);
      padding: 8px;
      border-radius: 8px;
      z-index: 10;
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <div id="toolbar">
    <button id="undoBtn">Undo</button>
    <button id="redoBtn">Redo</button>
    <button id="newBtn">New</button>
    <button id="eraseBtn">Eraser</button>
    <input type="color" id="colorPicker">
    <button id="increaseBtn">+</button>
    <button id="decreaseBtn">-</button>
    <input type="number" id="sizeInput" min="1" max="100000000000000000000000" value="5" step="1">
    <span id="zoomInfo">Zoom: 1x</span>
  </div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    let width = canvas.width = window.innerWidth;
    let height = canvas.height = window.innerHeight;

    let brushColor = "#000000";
    let baseBrushSize = 5;
    let isErasing = false;

    let offsetX = 0, offsetY = 0;
    let startTouches = [];
    let scale = 1;
    let panX = 0, panY = 0;
    let isDrawing = false;

    let undoStack = [];
    let redoStack = [];

    const colorPicker = document.getElementById("colorPicker");
    const sizeInput = document.getElementById("sizeInput");
    const increaseBtn = document.getElementById("increaseBtn");
    const decreaseBtn = document.getElementById("decreaseBtn");
    const undoBtn = document.getElementById("undoBtn");
    const redoBtn = document.getElementById("redoBtn");
    const newBtn = document.getElementById("newBtn");
    const eraseBtn = document.getElementById("eraseBtn");
    const zoomInfo = document.getElementById("zoomInfo");

    function updateZoomDisplay() {
      zoomInfo.textContent = `Zoom: ${scale.toFixed(2)}x`;
    }

    function getCurrentBrushSize() {
      return Math.min(baseBrushSize / Math.sqrt(scale), 1e+23);
    }

    function saveState() {
      undoStack.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
      if (undoStack.length > 50) undoStack.shift();
      redoStack = [];
    }

    function undo() {
      if (undoStack.length > 0) {
        redoStack.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
        let state = undoStack.pop();
        ctx.putImageData(state, 0, 0);
      }
    }

    function redo() {
      if (redoStack.length > 0) {
        undoStack.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
        let state = redoStack.pop();
        ctx.putImageData(state, 0, 0);
      }
    }

    function clearCanvas() {
      saveState();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    colorPicker.addEventListener("input", () => {
      brushColor = colorPicker.value;
      isErasing = false;
    });

    sizeInput.addEventListener("input", () => {
      let val = parseFloat(sizeInput.value);
      if (val > 1e+23) val = 1e+23;
      baseBrushSize = val;
      sizeInput.value = baseBrushSize;
    });

    increaseBtn.addEventListener("click", () => {
      baseBrushSize = Math.min(baseBrushSize + 1, 1e+23);
      sizeInput.value = baseBrushSize;
    });

    decreaseBtn.addEventListener("click", () => {
      baseBrushSize = Math.max(baseBrushSize - 1, 1);
      sizeInput.value = baseBrushSize;
    });

    undoBtn.addEventListener("click", undo);
    redoBtn.addEventListener("click", redo);
    newBtn.addEventListener("click", clearCanvas);
    eraseBtn.addEventListener("click", () => {
      isErasing = true;
    });

    canvas.addEventListener("touchstart", (e) => {
      if (e.touches.length === 1) {
        saveState();
        const touch = e.touches[0];
        const x = (touch.clientX - panX) / scale;
        const y = (touch.clientY - panY) / scale;
        ctx.beginPath();
        ctx.moveTo(x, y);
        isDrawing = true;
      } else if (e.touches.length === 3) {
        startTouches = [...e.touches];
      }
    });

    canvas.addEventListener("touchmove", (e) => {
      e.preventDefault();
      if (e.touches.length === 1 && isDrawing) {
        const touch = e.touches[0];
        const x = (touch.clientX - panX) / scale;
        const y = (touch.clientY - panY) / scale;

        ctx.lineTo(x, y);
        ctx.strokeStyle = isErasing ? "#FFFFFF" : brushColor;
        ctx.lineWidth = getCurrentBrushSize();
        ctx.lineCap = "round";
        ctx.stroke();
      } else if (e.touches.length === 3) {
        const dx = e.touches[0].clientX - startTouches[0].clientX;
        const dy = e.touches[0].clientY - startTouches[0].clientY;
        panX += dx;
        panY += dy;
        startTouches = [...e.touches];
        redraw();
      } else if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (!canvas._lastDist) canvas._lastDist = dist;
        let zoomFactor = dist / canvas._lastDist;
        scale *= zoomFactor;
        scale = Math.min(Math.max(scale, 0.1), 100);
        canvas._lastDist = dist;
        updateZoomDisplay();
      }
    }, { passive: false });

    canvas.addEventListener("touchend", (e) => {
      isDrawing = false;
      if (e.touches.length < 2) {
        canvas._lastDist = null;
      }
    });

    function redraw() {
      let temp = ctx.getImageData(0, 0, canvas.width, canvas.height);
      ctx.setTransform(1, 0, 0, 1, 0, 0); // reset
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.setTransform(scale, 0, 0, scale, panX, panY);
      ctx.putImageData(temp, 0, 0);
    }

    window.addEventListener("resize", () => {
      const oldImg = ctx.getImageData(0, 0, canvas.width, canvas.height);
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
      ctx.putImageData(oldImg, 0, 0);
    });

    updateZoomDisplay();
  </script>
</body>
</html>
