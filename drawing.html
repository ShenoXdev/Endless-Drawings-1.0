<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Mobile Drawing</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      touch-action: none;
      user-select: none;
    }
    canvas {
      background: #fff;
      touch-action: none;
    }
    #ui {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(255,255,255,0.8);
      border-radius: 10px;
      padding: 10px;
      display: flex;
      gap: 5px;
      flex-wrap: wrap;
      z-index: 10;
    }
    #ui > * {
      font-size: 16px;
    }
  </style>
</head>
<body>
  <div id="ui">
    <input type="color" id="colorPicker" value="#000000" />
    <input type="number" id="brushSize" value="4" min="1" max="1000" />
    <button id="undoBtn">Undo</button>
    <button id="redoBtn">Redo</button>
  </div>
  <canvas id="canvas"></canvas>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const colorPicker = document.getElementById("colorPicker");
    const brushSize = document.getElementById("brushSize");
    const undoBtn = document.getElementById("undoBtn");
    const redoBtn = document.getElementById("redoBtn");

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    let drawing = false;
    let currentPath = null;
    let paths = [];
    let undonePaths = [];

    let isZooming = false;
    let isPanning = false;
    let lastTouchDist = 0;
    let zoom = 1;
    let offsetX = 0, offsetY = 0;
    let startOffsetX = 0, startOffsetY = 0;
    let touchStartX = 0, touchStartY = 0;

    // منع الرسم لمدة 2 ثانية بعد الزوم
    let allowDrawAfterZoom = true;
    let zoomTouchTimer = null;

    function getCanvasPos(touch) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: (touch.clientX - rect.left - offsetX) / zoom,
        y: (touch.clientY - rect.top - offsetY) / zoom
      };
    }

    function distance(p1, p2) {
      return Math.hypot(p1.clientX - p2.clientX, p1.clientY - p2.clientY);
    }

    function drawAll() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      ctx.translate(offsetX, offsetY);
      ctx.scale(zoom, zoom);
      for (const path of paths) {
        ctx.strokeStyle = path.color;
        ctx.lineWidth = path.size;
        ctx.lineJoin = ctx.lineCap = "round";
        ctx.beginPath();
        for (let i = 0; i < path.points.length; i++) {
          const p = path.points[i];
          if (i === 0) {
            ctx.moveTo(p.x, p.y);
          } else {
            ctx.lineTo(p.x, p.y);
          }
        }
        ctx.stroke();
      }
      ctx.restore();
    }

    canvas.addEventListener("touchstart", (e) => {
      e.preventDefault();

      if (e.touches.length === 3) {
        isPanning = true;
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        startOffsetX = offsetX;
        startOffsetY = offsetY;
        return;
      }

      if (e.touches.length === 2) {
        isZooming = true;
        allowDrawAfterZoom = false;
        lastTouchDist = distance(e.touches[0], e.touches[1]);
        touchStartX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
        touchStartY = (e.touches[0].clientY + e.touches[1].clientY) / 2;

        if (zoomTouchTimer) clearTimeout(zoomTouchTimer);
        zoomTouchTimer = setTimeout(() => {
          allowDrawAfterZoom = true;
        }, 2000);
        return;
      }

      if (e.touches.length === 1 && allowDrawAfterZoom && !isZooming && !isPanning) {
        const touch = e.touches[0];
        const pos = getCanvasPos(touch);
        drawing = true;
        currentPath = {
          color: colorPicker.value,
          size: parseFloat(brushSize.value),
          points: [pos]
        };
      }
    });

    canvas.addEventListener("touchmove", (e) => {
      e.preventDefault();

      if (isPanning && e.touches.length === 3) {
        const dx = e.touches[0].clientX - touchStartX;
        const dy = e.touches[0].clientY - touchStartY;
        offsetX = startOffsetX + dx;
        offsetY = startOffsetY + dy;
        drawAll();
        return;
      }

      if (isZooming && e.touches.length === 2) {
        const newDist = distance(e.touches[0], e.touches[1]);
        const scale = newDist / lastTouchDist;
        const newZoom = zoom * scale;

        const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
        const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;

        offsetX = centerX - (centerX - offsetX) * (newZoom / zoom);
        offsetY = centerY - (centerY - offsetY) * (newZoom / zoom);

        zoom = newZoom;
        lastTouchDist = newDist;
        drawAll();
        return;
      }

      if (drawing && e.touches.length === 1) {
        const touch = e.touches[0];
        const pos = getCanvasPos(touch);
        currentPath.points.push(pos);
        paths.push(currentPath);
        currentPath = {
          ...currentPath,
          points: [pos]
        };
        drawAll();
      }
    });

    canvas.addEventListener("touchend", (e) => {
      if (drawing && currentPath.points.length > 0) {
        paths.push(currentPath);
        undonePaths = [];
      }

      if (e.touches.length === 0) {
        isZooming = false;
        isPanning = false;
        drawing = false;
        allowDrawAfterZoom = true;
        if (zoomTouchTimer) {
          clearTimeout(zoomTouchTimer);
          zoomTouchTimer = null;
        }
      }
    });

    undoBtn.addEventListener("click", () => {
      if (paths.length > 0) {
        undonePaths.push(paths.pop());
        drawAll();
      }
    });

    redoBtn.addEventListener("click", () => {
      if (undonePaths.length > 0) {
        paths.push(undonePaths.pop());
        drawAll();
      }
    });

    window.addEventListener("resize", () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      drawAll();
    });

    drawAll();
  </script>
</body>
</html>
